<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <copyright file="SynchronizationContextInvokerBase.InvokeActionsAndFuncs.cs" company="Adrian Mos">
// Copyright (c) Adrian Mos with all rights reserved. Part of the IX Framework.
// </copyright>

using System;
using System.Threading;
using IX.StandardExtensions.Threading;

namespace IX.StandardExtensions.ComponentModel
{
    /// <summary>
    /// An abstract base class for a synchronization context invoker.
    /// </summary>
    /// <seealso cref="IX.StandardExtensions.ComponentModel.DisposableBase" />
    public abstract partial class SynchronizationContextInvokerBase : DisposableBase, INotifyThreadException
    {<#
for (int i = 1; i <= 8; i++)
{
    string[] types = new string[i];
    string[] names = new string[i];
    string[] nameTypes = new string[i];
    string[] parameters = new string[i];

    for (int j = 1; j <= i; j++)
    {
        int idx = j - 1;
        types[idx] = $"TParam{j}";
        names[idx] = $"param{j}";
        nameTypes[idx] = $"TParam{j} param{j}";
        if (idx != 7)
        {
            parameters[idx] = $"unpackedParameters.Item{j}";
        }
        else
        {
            parameters[idx] = "unpackedParameters.Rest";
        }
    }

    string paramTypes = string.Join(", ", types);
    string paramNames = string.Join(", ", names);
    string paramNameTypes = string.Join(", ", nameTypes);
    string paramParameters = string.Join(", ", parameters);
#>

        /// <summary>
        /// Invokes the specified action using the synchronization context asynchronously, or as fire-and-forget if there is no synchronization context available.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action to invoke.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        protected void Invoke<<#= paramTypes #>>(Action<<#= paramTypes #>> action, <#= paramNameTypes #>)
        {
            this.ThrowIfCurrentObjectDisposed();

            if (action == null)
            {
                throw new ArgumentNullException(nameof(action));
            }

            if (EnvironmentSettings.InvokeSynchronouslyOnCurrentThread)
            {
                action(<#= paramNames #>);
                return;
            }

            SynchronizationContext currentSynchronizationContext = this.synchronizationContext ?? EnvironmentSettings.GetUsableSynchronizationContext();

            if (currentSynchronizationContext == null)
            {
                if (EnvironmentSettings.InvokeSynchronously)
                {
                    action(<#= paramNames #>);
                }
                else
                {
                    this.FireAndForget(action, <#= paramNames #>);
                }
            }
            else
            {
                var state = new Tuple<SynchronizationContextInvokerBase, Action<<#= paramTypes #>>, Tuple<<#= paramTypes #>>>(this, action, new Tuple<<#= paramTypes #>>(<#= paramNames #>));

#pragma warning disable HAA0603 // Delegate allocation from a method group - Unavoidable
                if (EnvironmentSettings.InvokeSynchronously)
                {
                    currentSynchronizationContext.Send(
                        SendOrPost,
                        state);
                }
                else
                {
                    currentSynchronizationContext.Post(
                        SendOrPost,
                        state);
                }
#pragma warning restore HAA0603 // Delegate allocation from a method group

                void SendOrPost(object innerState)
                {
                    var unpackedState = (Tuple<SynchronizationContextInvokerBase, Action<<#= paramTypes #>>, Tuple<<#= paramTypes #>>>)innerState;
                    SynchronizationContextInvokerBase invoker = unpackedState.Item1;
                    Tuple<<#= paramTypes #>> unpackedParameters = unpackedState.Item3;

                    try
                    {
                        unpackedState.Item2(<#= paramParameters #>);
                    }
                    catch (Exception ex)
                    {
                        unpackedState.Item1.InvokeExceptionOccurredOnSeparateThread(ex);
                    }
                }
            }
        }

        /// <summary>
        /// Invokes an action and forgets about it, allowing it to run uninterrupted in the background.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action to invoke.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        protected void FireAndForget<<#= paramTypes #>>(Action<<#= paramTypes #>> action, <#= paramNameTypes #>)
#pragma warning disable HAA0603 // Delegate allocation from a method group - Unavoidable
            => Fire.AndForget(action, <#= paramNames #>, this.InvokeExceptionOccurredOnSeparateThread);
#pragma warning restore HAA0603 // Delegate allocation from a method group
<#
}
#>
    }
}