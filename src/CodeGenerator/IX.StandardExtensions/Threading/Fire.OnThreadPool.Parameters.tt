<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <copyright file="Fire.OnThreadPool.Parameters.cs" company="Adrian Mos">
// Copyright (c) Adrian Mos with all rights reserved. Part of the IX Framework.
// </copyright>

using System;
using System.Threading;
using System.Threading.Tasks;

using IX.StandardExtensions.Contracts;

using JetBrains.Annotations;

namespace IX.StandardExtensions.Threading
{
    /// <summary>
    /// A class that provides methods and extensions to fire events.
    /// </summary>
    public static partial class Fire
    {
#pragma warning disable HAA0303 // Lambda or anonymous method in a generic method allocates a delegate instance - The lambdas themselves rely on generics<#
for (int i = 1; i <= 8; i++)
{
    string[] types = new string[i];
    string[] names = new string[i];
    string[] nameTypes = new string[i];
    string[] parameters = new string[i];

    for (int j = 1; j <= i; j++)
    {
        int idx = j - 1;
        types[idx] = $"TParam{j}";
        names[idx] = $"param{j}";
        nameTypes[idx] = $"TParam{j} param{j}";
        if (idx != 7)
        {
            parameters[idx] = $"unpackedParameters.Item{j}";
        }
        else
        {
            parameters[idx] = "unpackedParameters.Rest";
        }
    }

    string paramTypes = string.Join(", ", types);
    string paramNames = string.Join(", ", names);
    string paramNameTypes = string.Join(", ", nameTypes);
    string paramParameters = string.Join(", ", parameters);
#>

        /// <summary>
        /// Starts an action on a thread in the thread pool.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The optional cancellation token for the operation.</param>
        /// <returns>The task representing the current asynchronous operation.</returns>
#if NETSTANDARD1_2
        /// <remarks><para>Due to the way the task scheduler works, it is not a guarantee that the method will run on a separate thread.</para></remarks>
#endif
        public static Task OnThreadPool<<#= paramTypes #>>(
            Action<<#= paramTypes #>> action,
            <#= paramNameTypes #>,
            CancellationToken cancellationToken = default) => ExecuteOnThreadPool(
                (st, ct) =>
                {
                    Contract.RequiresNotNullPrivate(st, nameof(st));
                    Contract.RequiresArgumentOfTypePrivate<Tuple<Action<<#= paramTypes #>>, Tuple<<#= paramTypes #>>>>(st, nameof(st));

                    var innerState = (Tuple<Action<<#= paramTypes #>>, Tuple<<#= paramTypes #>>>)st;
                    var actionL1 = innerState.Item1;
                    var unpackedParameters = innerState.Item2;

                    ct.ThrowIfCancellationRequested();

                    actionL1(<#= paramParameters #>);
                },
                new Tuple<Action<<#= paramTypes #>>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>)),
                cancellationToken);

        /// <summary>
        /// Starts an action on a thread in the thread pool.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The optional cancellation token for the operation.</param>
        /// <returns>The task representing the current asynchronous operation.</returns>
#if NETSTANDARD1_2
        /// <remarks><para>Due to the way the task scheduler works, it is not a guarantee that the method will run on a separate thread.</para></remarks>
#endif
        public static Task OnThreadPool<<#= paramTypes #>>(
            Action<<#= paramTypes #>, CancellationToken> action,
            <#= paramNameTypes #>,
            CancellationToken cancellationToken = default) => ExecuteOnThreadPool(
                (st, ct) =>
                {
                    Contract.RequiresNotNullPrivate(st, nameof(st));
                    Contract.RequiresArgumentOfTypePrivate<Tuple<Action<<#= paramTypes #>, CancellationToken>, Tuple<<#= paramTypes #>>>>(st, nameof(st));

                    var innerState = (Tuple<Action<<#= paramTypes #>, CancellationToken>, Tuple<<#= paramTypes #>>>)st;
                    var actionL1 = innerState.Item1;
                    var unpackedParameters = innerState.Item2;

                    ct.ThrowIfCancellationRequested();

                    actionL1(<#= paramParameters #>, ct);
                },
                new Tuple<Action<<#= paramTypes #>, CancellationToken>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>)),
                cancellationToken);

        /// <summary>
        /// Starts an action on a thread in the thread pool.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The optional cancellation token for the operation.</param>
        /// <returns>The task representing the current asynchronous operation.</returns>
#if NETSTANDARD1_2
        /// <remarks><para>Due to the way the task scheduler works, it is not a guarantee that the method will run on a separate thread.</para></remarks>
#endif
        public static Task OnThreadPool<<#= paramTypes #>>(
            Func<<#= paramTypes #>, Task> action,
            <#= paramNameTypes #>,
            CancellationToken cancellationToken = default) => ExecuteOnThreadPool(
                (st, ct) =>
                {
                    Contract.RequiresNotNullPrivate(st, nameof(st));
                    Contract.RequiresArgumentOfTypePrivate<Tuple<Func<<#= paramTypes #>, Task>, Tuple<<#= paramTypes #>>>>(st, nameof(st));

                    var innerState = (Tuple<Func<<#= paramTypes #>, Task>, Tuple<<#= paramTypes #>>>)st;
                    var actionL1 = innerState.Item1;
                    var unpackedParameters = innerState.Item2;

                    ct.ThrowIfCancellationRequested();

                    return actionL1(<#= paramParameters #>);
                },
                new Tuple<Func<<#= paramTypes #>, Task>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>)),
                cancellationToken);

        /// <summary>
        /// Starts an action on a thread in the thread pool.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The optional cancellation token for the operation.</param>
        /// <returns>The task representing the current asynchronous operation.</returns>
#if NETSTANDARD1_2
        /// <remarks><para>Due to the way the task scheduler works, it is not a guarantee that the method will run on a separate thread.</para></remarks>
#endif
        public static Task OnThreadPool<<#= paramTypes #>>(
            Func<<#= paramTypes #>, CancellationToken, Task> action,
            <#= paramNameTypes #>,
            CancellationToken cancellationToken = default) => ExecuteOnThreadPool(
                (st, ct) =>
                {
                    Contract.RequiresNotNullPrivate(st, nameof(st));
                    Contract.RequiresArgumentOfTypePrivate<Tuple<Func<<#= paramTypes #>, CancellationToken, Task>, Tuple<<#= paramTypes #>>>>(st, nameof(st));

                    var innerState = (Tuple<Func<<#= paramTypes #>, CancellationToken, Task>, Tuple<<#= paramTypes #>>>)st;
                    var actionL1 = innerState.Item1;
                    var unpackedParameters = innerState.Item2;

                    ct.ThrowIfCancellationRequested();

                    return actionL1(<#= paramParameters #>, ct);
                },
                new Tuple<Func<<#= paramTypes #>, CancellationToken, Task>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>)),
                cancellationToken);

        /// <summary>
        /// Starts an action on a thread in the thread pool.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
        /// <typeparam name="TResult">The expected result type.</typeparam>
<#
    }
#>
        /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The optional cancellation token for the operation.</param>
        /// <returns>The task representing the current asynchronous operation.</returns>
#if NETSTANDARD1_2
        /// <remarks><para>Due to the way the task scheduler works, it is not a guarantee that the method will run on a separate thread.</para></remarks>
#endif
        public static Task<TResult> OnThreadPool<<#= paramTypes #>, TResult>(
            Func<<#= paramTypes #>, TResult> action,
            <#= paramNameTypes #>,
            CancellationToken cancellationToken = default) => ExecuteOnThreadPool(
                (st, ct) =>
                {
                    Contract.RequiresNotNullPrivate(st, nameof(st));
                    Contract.RequiresArgumentOfTypePrivate<Tuple<Func<<#= paramTypes #>, TResult>, Tuple<<#= paramTypes #>>>>(st, nameof(st));

                    var innerState = (Tuple<Func<<#= paramTypes #>, TResult>, Tuple<<#= paramTypes #>>>)st;
                    var actionL1 = innerState.Item1;
                    var unpackedParameters = innerState.Item2;

                    ct.ThrowIfCancellationRequested();

                    return actionL1(<#= paramParameters #>);
                },
                new Tuple<Func<<#= paramTypes #>, TResult>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>)),
                cancellationToken);

        /// <summary>
        /// Starts an action on a thread in the thread pool.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <typeparam name="TResult">The expected result type.</typeparam>
        /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The optional cancellation token for the operation.</param>
        /// <returns>The task representing the current asynchronous operation.</returns>
#if NETSTANDARD1_2
        /// <remarks><para>Due to the way the task scheduler works, it is not a guarantee that the method will run on a separate thread.</para></remarks>
#endif
        public static Task<TResult> OnThreadPool<<#= paramTypes #>, TResult>(
            Func<<#= paramTypes #>, CancellationToken, TResult> action,
            <#= paramNameTypes #>,
            CancellationToken cancellationToken = default) => ExecuteOnThreadPool(
                (st, ct) =>
                {
                    Contract.RequiresNotNullPrivate(st, nameof(st));
                    Contract.RequiresArgumentOfTypePrivate<Tuple<Func<<#= paramTypes #>, CancellationToken, TResult>, Tuple<<#= paramTypes #>>>>(st, nameof(st));

                    var innerState = (Tuple<Func<<#= paramTypes #>, CancellationToken, TResult>, Tuple<<#= paramTypes #>>>)st;
                    var actionL1 = innerState.Item1;
                    var unpackedParameters = innerState.Item2;

                    ct.ThrowIfCancellationRequested();

                    return actionL1(<#= paramParameters #>, ct);
                },
                new Tuple<Func<<#= paramTypes #>, CancellationToken, TResult>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>)),
                cancellationToken);

        /// <summary>
        /// Starts an action on a thread in the thread pool.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <typeparam name="TResult">The expected result type.</typeparam>
        /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The optional cancellation token for the operation.</param>
        /// <returns>The task representing the current asynchronous operation.</returns>
#if NETSTANDARD1_2
        /// <remarks><para>Due to the way the task scheduler works, it is not a guarantee that the method will run on a separate thread.</para></remarks>
#endif
        public static Task<TResult> OnThreadPool<<#= paramTypes #>, TResult>(
            Func<<#= paramTypes #>, Task<TResult>> action,
            <#= paramNameTypes #>,
            CancellationToken cancellationToken = default) => ExecuteOnThreadPool(
                (st, ct) =>
                {
                    Contract.RequiresNotNullPrivate(st, nameof(st));
                    Contract.RequiresArgumentOfTypePrivate<Tuple<Func<<#= paramTypes #>, Task<TResult>>, Tuple<<#= paramTypes #>>>>(st, nameof(st));

                    var innerState = (Tuple<Func<<#= paramTypes #>, Task<TResult>>, Tuple<<#= paramTypes #>>>)st;
                    var actionL1 = innerState.Item1;
                    var unpackedParameters = innerState.Item2;

                    ct.ThrowIfCancellationRequested();

                    return actionL1(<#= paramParameters #>);
                },
                new Tuple<Func<<#= paramTypes #>, Task<TResult>>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>)),
                cancellationToken);

        /// <summary>
        /// Starts an action on a thread in the thread pool.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <typeparam name="TResult">The expected result type.</typeparam>
        /// <param name="action">The action to execute.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The optional cancellation token for the operation.</param>
        /// <returns>The task representing the current asynchronous operation.</returns>
#if NETSTANDARD1_2
        /// <remarks><para>Due to the way the task scheduler works, it is not a guarantee that the method will run on a separate thread.</para></remarks>
#endif
        public static Task<TResult> OnThreadPool<<#= paramTypes #>, TResult>(
            Func<<#= paramTypes #>, CancellationToken, Task<TResult>> action,
            <#= paramNameTypes #>,
            CancellationToken cancellationToken = default) => ExecuteOnThreadPool(
                (st, ct) =>
                {
                    Contract.RequiresNotNullPrivate(st, nameof(st));
                    Contract.RequiresArgumentOfTypePrivate<Tuple<Func<<#= paramTypes #>, CancellationToken, Task<TResult>>, Tuple<<#= paramTypes #>>>>(st, nameof(st));

                    var innerState = (Tuple<Func<<#= paramTypes #>, CancellationToken, Task<TResult>>, Tuple<<#= paramTypes #>>>)st;
                    var actionL1 = innerState.Item1;
                    var unpackedParameters = innerState.Item2;

                    ct.ThrowIfCancellationRequested();

                    return actionL1(<#= paramParameters #>, ct);
                },
                new Tuple<Func<<#= paramTypes #>, CancellationToken, Task<TResult>>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>)),
                cancellationToken);
<#
}
#>
#pragma warning restore HAA0303 // Lambda or anonymous method in a generic method allocates a delegate instance

    }
}