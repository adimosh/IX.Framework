<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <copyright file="Fire.AndForgetActionsAndFuncs.cs" company="Adrian Mos">
// Copyright (c) Adrian Mos with all rights reserved. Part of the IX Framework.
// </copyright>

using System;
using System.Threading;
using System.Threading.Tasks;

using IX.StandardExtensions.Contracts;

using JetBrains.Annotations;

namespace IX.StandardExtensions.Threading
{
    /// <summary>
    /// A class that provides methods and extensions to fire events.
    /// </summary>
    public static partial class Fire
    {
#pragma warning disable HAA0603 // Delegate allocation from a method group - This is acceptable
#pragma warning disable HAA0303 // Lambda or anonymous method in a generic method allocates a delegate instance - The lambdas themselves rely on generics<#
for (int i = 1; i <= 8; i++)
{
    string[] types = new string[i];
    string[] names = new string[i];
    string[] nameTypes = new string[i];
    string[] parameters = new string[i];

    for (int j = 1; j <= i; j++)
    {
        int idx = j - 1;
        types[idx] = $"TParam{j}";
        names[idx] = $"param{j}";
        nameTypes[idx] = $"TParam{j} param{j}";
        if (idx != 7)
        {
            parameters[idx] = $"unpackedParameters.Item{j}";
        }
        else
        {
            parameters[idx] = "unpackedParameters.Rest";
        }
    }

    string paramTypes = string.Join(", ", types);
    string paramNames = string.Join(", ", names);
    string paramNameTypes = string.Join(", ", nameTypes);
    string paramParameters = string.Join(", ", parameters);
#>

        /// <summary>
        /// Fires a method on a separate thread, and forgets about it completely, only invoking a continuation if there was an exception.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The cancellation token.</param>
        public static void AndForget<<#= paramTypes #>>([CanBeNull] Action<<#= paramTypes #>> action, <#= paramNameTypes #>, CancellationToken cancellationToken = default)
            => AndForget(action, <#= paramNames #>, EnvironmentSettings.DefaultFireAndForgetUnhandledExceptionHandler, cancellationToken);

        /// <summary>
        /// Fires a method on a separate thread, and forgets about it completely, only invoking a continuation if there was an exception.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="exceptionHandler">The exception handler. This parameter can be null.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        public static void AndForget<<#= paramTypes #>>([CanBeNull] Action<<#= paramTypes #>> action, <#= paramNameTypes #>, [CanBeNull] Action<Exception> exceptionHandler, CancellationToken cancellationToken = default)
        {
            Contract.RequiresNotNull(action, nameof(action));

            var state = new Tuple<Action<<#= paramTypes #>>, Tuple<<#= paramTypes #>>>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>));
            var runningTask = new Task(ExecuteAction, state, cancellationToken);

            void ExecuteAction(object innerState)
            {
                var unpackedState = (Tuple<Action<<#= paramTypes #>>, Tuple<<#= paramTypes #>>>)innerState;
                Tuple<<#= paramTypes #>> unpackedParameters = unpackedState.Item2;

                unpackedState.Item1(<#= paramParameters #>);
            }

            runningTask.ContinueWith(
                continuationAction: StandardContinuation,
                state: exceptionHandler,
                continuationOptions: TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously,
                scheduler: GetCurrentTaskScheduler(),
                cancellationToken: cancellationToken);

            runningTask.Start(TaskScheduler.Default);

            if (runningTask.IsCompleted)
            {
                return;
            }

            runningTask.ConfigureAwait(false);
        }

        /// <summary>
        /// Fires a method on a separate thread, and forgets about it completely, only invoking a continuation if there was an exception.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The cancellation token.</param>
        public static void AndForget<<#= paramTypes #>>([CanBeNull] Action<<#= paramTypes #>, CancellationToken> action, <#= paramNameTypes #>, CancellationToken cancellationToken = default)
            => AndForget(action, <#= paramNames #>, EnvironmentSettings.DefaultFireAndForgetUnhandledExceptionHandler, cancellationToken);

        /// <summary>
        /// Fires a method on a separate thread, and forgets about it completely, only invoking a continuation if there was an exception.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="exceptionHandler">The exception handler. This parameter can be null.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        public static void AndForget<<#= paramTypes #>>([CanBeNull] Action<<#= paramTypes #>, CancellationToken> action, <#= paramNameTypes #>, [CanBeNull] Action<Exception> exceptionHandler, CancellationToken cancellationToken = default)
        {
            Contract.RequiresNotNull(action, nameof(action));

            var state = new Tuple<Action<<#= paramTypes #>, CancellationToken>, Tuple<<#= paramTypes #>>, CancellationToken>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>), cancellationToken);
            var runningTask = new Task(ExecuteAction, state, cancellationToken);

            void ExecuteAction(object innerState)
            {
                var unpackedState = (Tuple<Action<<#= paramTypes #>, CancellationToken>, Tuple<<#= paramTypes #>>, CancellationToken>)innerState;
                Tuple<<#= paramTypes #>> unpackedParameters = unpackedState.Item2;

                unpackedState.Item1(<#= paramParameters #>, unpackedState.Item3);
            }

            runningTask.ContinueWith(
                continuationAction: StandardContinuation,
                state: exceptionHandler,
                continuationOptions: TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously,
                scheduler: GetCurrentTaskScheduler(),
                cancellationToken: cancellationToken);

            runningTask.Start(TaskScheduler.Default);

            if (runningTask.IsCompleted)
            {
                return;
            }

            runningTask.ConfigureAwait(false);
        }

        /// <summary>
        /// Fires a method on a separate thread, and forgets about it completely, only invoking a continuation if there was an exception.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The cancellation token.</param>
        public static void AndForget<<#= paramTypes #>>([CanBeNull] Func<<#= paramTypes #>, Task> action, <#= paramNameTypes #>, CancellationToken cancellationToken = default)
            => AndForget(action, <#= paramNames #>, EnvironmentSettings.DefaultFireAndForgetUnhandledExceptionHandler, cancellationToken);

        /// <summary>
        /// Fires a method on a separate thread, and forgets about it completely, only invoking a continuation if there was an exception.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="exceptionHandler">The exception handler. This parameter can be null.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        public static void AndForget<<#= paramTypes #>>([CanBeNull] Func<<#= paramTypes #>, Task> action, <#= paramNameTypes #>, [CanBeNull] Action<Exception> exceptionHandler, CancellationToken cancellationToken = default)
        {
            Contract.RequiresNotNull(action, nameof(action));

            var runningTask = new Task(
                (state) =>
                {
                    var brokenState = (Tuple<Func<<#= paramTypes #>, Task>, Tuple<<#= paramTypes #>>, Action<Exception>, TaskScheduler, CancellationToken>)state;
                    try
                    {
                        Tuple<<#= paramTypes #>> unpackedParameters = brokenState.Item2;
                        Task task = brokenState.Item1(<#= paramParameters #>);

                        if (!task.IsCompleted)
                        {
                            task.ConfigureAwait(false);

                            if (brokenState.Item3 != null)
                            {
                                task.ContinueWith(
                                    continuationAction: StandardContinuation,
                                    state: brokenState.Item3,
                                    continuationOptions: TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously,
                                    scheduler: brokenState.Item4,
                                    cancellationToken: brokenState.Item5);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        if (brokenState.Item3 != null)
                        {
                            var task = new Task(
                            (state2) =>
                            {
                                var brokenState2 = (Tuple<Exception, Action<Exception>>)state2;

                                brokenState2.Item2(brokenState2.Item1);
                            },
                            new Tuple<Exception, Action<Exception>>(ex, brokenState.Item3),
                            brokenState.Item5);

                            task.ConfigureAwait(false);

                            task.Start(brokenState.Item4);
                        }
                    }
                },
                new Tuple<Func<<#= paramTypes #>, Task>, Tuple<<#= paramTypes #>>, Action<Exception>, TaskScheduler, CancellationToken>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>), exceptionHandler, GetCurrentTaskScheduler(), cancellationToken),
                cancellationToken);

            runningTask.Start(TaskScheduler.Default);

            if (runningTask.IsCompleted)
            {
                return;
            }

            runningTask.ConfigureAwait(false);
        }

        /// <summary>
        /// Fires a method on a separate thread, and forgets about it completely, only invoking a continuation if there was an exception.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="cancellationToken">The cancellation token.</param>
        public static void AndForget<<#= paramTypes #>>([CanBeNull] Func<<#= paramTypes #>, CancellationToken, Task> action, <#= paramNameTypes #>, CancellationToken cancellationToken = default)
            => AndForget(action, <#= paramNames #>, EnvironmentSettings.DefaultFireAndForgetUnhandledExceptionHandler, cancellationToken);

        /// <summary>
        /// Fires a method on a separate thread, and forgets about it completely, only invoking a continuation if there was an exception.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TParam<#= j #>">The type of parameter to be passed to the invoked method at index <#= j - 1 #>.</typeparam>
<#
    }
#>
        /// <param name="action">The action.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="param<#= j #>">A parameter of type <typeparamref name="TParam<#= j #>" /> to pass to the invoked method at index <#= j - 1 #>.</param>
<#
    }
#>
        /// <param name="exceptionHandler">The exception handler. This parameter can be null.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        public static void AndForget<<#= paramTypes #>>([CanBeNull] Func<<#= paramTypes #>, CancellationToken, Task> action, <#= paramNameTypes #>, [CanBeNull] Action<Exception> exceptionHandler, CancellationToken cancellationToken = default)
        {
            Contract.RequiresNotNull(action, nameof(action));

            var runningTask = new Task(
                (state) =>
                {
                    var brokenState = (Tuple<Func<<#= paramTypes #>, CancellationToken, Task>, Tuple<<#= paramTypes #>>, Action<Exception>, TaskScheduler, CancellationToken>)state;
                    try
                    {
                        Tuple<<#= paramTypes #>> unpackedParameters = brokenState.Item2;
                        Task task = brokenState.Item1(<#= paramParameters #>, brokenState.Item5);

                        if (!task.IsCompleted)
                        {
                            task.ConfigureAwait(false);

                            if (brokenState.Item3 != null)
                            {
                                task.ContinueWith(
                                    continuationAction: StandardContinuation,
                                    state: brokenState.Item3,
                                    continuationOptions: TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously,
                                    scheduler: brokenState.Item4,
                                    cancellationToken: brokenState.Item5);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        if (brokenState.Item3 != null)
                        {
                            var task = new Task(
                            (state2) =>
                            {
                                var brokenState2 = (Tuple<Exception, Action<Exception>>)state2;

                                brokenState2.Item2(brokenState2.Item1);
                            },
                            new Tuple<Exception, Action<Exception>>(ex, brokenState.Item3),
                            brokenState.Item5);

                            task.ConfigureAwait(false);

                            task.Start(brokenState.Item4);
                        }
                    }
                },
                new Tuple<Func<<#= paramTypes #>, CancellationToken, Task>, Tuple<<#= paramTypes #>>, Action<Exception>, TaskScheduler, CancellationToken>(action, new Tuple<<#= paramTypes #>>(<#= paramNames #>), exceptionHandler, GetCurrentTaskScheduler(), cancellationToken),
                cancellationToken);

            runningTask.Start(TaskScheduler.Default);

            if (runningTask.IsCompleted)
            {
                return;
            }

            runningTask.ConfigureAwait(false);
        }
<#
}
#>
#pragma warning restore HAA0303 // Lambda or anonymous method in a generic method allocates a delegate instance
#pragma warning restore HAA0603 // Delegate allocation from a method group

    }
}